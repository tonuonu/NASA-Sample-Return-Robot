/*
 *  Copyright (c) 2013 Tonu Samuel
 *  All rights reserved.
 *
 *  This file is part of robot "Kuukulgur".
 *
 *  This is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this software.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include <stdint.h>
#include <string.h>
#include "rskrx630def.h"
#include "iorx630.h"
#include "switch.h"

/* Switch flag global variable */
volatile uint8_t gSwitchFlag = 0x00;
/* Switch standby ready global variable */
volatile bool gSwitchStandbyReady = true;
/* Detected switch faults counter variable */
volatile uint16_t gSwitchFaultsDetected = 0;
/* Switch press callback pointer declaration */
void (*gSwitchPressCallbackFunc)(void) = NULL;
/* Switch release callback pointer declaration */
void (*gSwitchReleaseCallbackFunc)(void) = NULL;
/* Start debounce timer function prototype */ 
void StartDebounceTimer(uint16_t);

void InitialiseSwitchInterrupts(void) {
    gSwitchFlag = 0x00;    /* Reset the switch flag */
  
    /* Reset the switch standby ready flag */
    gSwitchStandbyReady = true;

    /* Set P3_x (SWx) as an input */
    PORT3.PDR.BIT.B0 = 0;
    PORT3.PDR.BIT.B1 = 0;
    PORT3.PDR.BIT.B2 = 0;
    PORT3.PDR.BIT.B3 = 0;  
    
    /* Enable pullups */
    PORT3.PCR.BIT.B0 = 1;
    PORT3.PCR.BIT.B1 = 1;
    PORT3.PCR.BIT.B2 = 1;
    PORT3.PCR.BIT.B3 = 1;
    
    /* Enable write to PFSWE bit */
    MPC.PWPR.BYTE = 0x00;
    /* Disable write protection to PFS registers */
    MPC.PWPR.BYTE = 0x40;

    MPC.P30PFS.BIT.ISEL = 0x1;  /* Set IRQ0 on Port3 as an input pin */
    MPC.P31PFS.BIT.ISEL = 0x1;  /* Set IRQ1 on Port3 as an input pin */
    MPC.P32PFS.BIT.ISEL = 0x1;  /* Set IRQ2 on Port3 as an input pin */
    MPC.P33PFS.BIT.ISEL = 0x1;  /* Set IRQ3 on Port3 as an input pin */

    /* Select the pin function as IO */
    MPC.P30PFS.BIT.PSEL = 0x0;
    MPC.P31PFS.BIT.PSEL = 0x0;
    MPC.P32PFS.BIT.PSEL = 0x0;
    MPC.P33PFS.BIT.PSEL = 0x0;
    
    /* Enable write protection to PFS registers */
    MPC.PWPR.BYTE = 0x80;
  
    /* Enable digital pin filtering for all IRQ pins */
    ICU.IRQFLTE0.BYTE = 1; 
    ICU.IRQFLTC0.BIT.FCLKSEL0=0x3; // PCLK/64 for IRQ0
    ICU.IRQFLTC0.BIT.FCLKSEL1=0x3; // PCLK/64 for IRQ1
    ICU.IRQFLTC0.BIT.FCLKSEL2=0x3; // PCLK/64 for IRQ2
    ICU.IRQFLTC0.BIT.FCLKSEL3=0x3; // PCLK/64 for IRQ3
  
    /* Configure switch SW4..SW1 (IRQ0..IRQ3) */
    IEN(ICU, IRQ0) = 0x0;  
    IEN(ICU, IRQ1) = 0x0;  
    IEN(ICU, IRQ2) = 0x0;  
    IEN(ICU, IRQ3) = 0x0;  
  
    /* Set detection direction as falling edge */
    ICU.IRQCR[0].BIT.IRQMD = 0x1;  
    ICU.IRQCR[1].BIT.IRQMD = 0x1;  
    ICU.IRQCR[2].BIT.IRQMD = 0x1;  
    ICU.IRQCR[3].BIT.IRQMD = 0x1;  

    /* Clear IR flag */
    IR(ICU, IRQ0) = 0x0;            
    IR(ICU, IRQ1) = 0x0;            
    IR(ICU, IRQ2) = 0x0;            
    IR(ICU, IRQ3) = 0x0;            

    /* Set interrupt priority level to 7 */
    IPR(ICU, IRQ0) = SWITCH_IPL;  
    IPR(ICU, IRQ1) = SWITCH_IPL;  
    IPR(ICU, IRQ2) = SWITCH_IPL;  
    IPR(ICU, IRQ3) = SWITCH_IPL;  

    /* Enable SW4..SW1 interrupt requests */
    IEN(ICU, IRQ0) = 0x1;
    IEN(ICU, IRQ1) = 0x1;
    IEN(ICU, IRQ2) = 0x1;
    IEN(ICU, IRQ3) = 0x1;
}

void SetSwitchPressCallback(void(*callback)(void)) {
    /* Store the callback function pointer into the global variable */
    gSwitchPressCallbackFunc = callback;
}

void SetSwitchReleaseCallback(void(*callback)(void)) {
    /* Store the callback function pointer into the global variable */
    gSwitchReleaseCallbackFunc = callback;
}

void ControlSwitchInterrupts(uint8_t control) {
    /* Check if control input is 0x1 */
    if(control) {
        /* Enable SW4..SW1 interrupt requests */
        IEN(ICU, IRQ0) = 0x1;
        IEN(ICU, IRQ1) = 0x1;
        IEN(ICU, IRQ2) = 0x1;
        IEN(ICU, IRQ3) = 0x1;
    } else { /* Control input is 0x0 */
        /* Disable SW4..SW1 interrupts */
        IEN(ICU, IRQ0) = 0x0;
        IEN(ICU, IRQ1) = 0x0;
        IEN(ICU, IRQ2) = 0x0;
        IEN(ICU, IRQ3) = 0x0;
    }
}  

#pragma vector=VECT_ICU_IRQ0
__interrupt void Excep_IRQ0(void) {
    /* Disable switch 1 interrupts */
    IEN(ICU, IRQ0) = 0x0;
    /* Set standby ready flag as false */
    gSwitchStandbyReady = false;
            
    /* Check if interrupt was generated by falling edge */
    if(ICU.IRQCR[0].BIT.IRQMD == 0x1) {
        /* Start debounce timer */
        StartDebounceTimer(DEBOUNCE_SHORT);    
    
        /* Set detection direction as rising edge */
        ICU.IRQCR[0].BIT.IRQMD = 0x2;
        
        /* Set global switch flag to indicate SW4 is held down */
        gSwitchFlag |= SWITCHHOLD_4;
    } else {
        /* Start debounce timer */
        StartDebounceTimer(DEBOUNCE_LONG);
      
        /* Set detection direction to falling edge */
        ICU.IRQCR[0].BIT.IRQMD = 0x1;
    
        /* Clear SW4 held-down flag bit in switch flag */
        gSwitchFlag &= (SWITCHPRESS_ALL | ~SWITCHHOLD_4);
    
        /* Set global switch flag to indicate SW4 press complete */
        gSwitchFlag |= SWITCHPRESS_4;
LED3=LED_OFF;
        /* Check if switch release callback function is not NULL */
        if(gSwitchReleaseCallbackFunc) {
LED6=LED_ON;
            /* Execute user callback function */
            gSwitchReleaseCallbackFunc();
        }
    }
}

#pragma vector=VECT_ICU_IRQ1
__interrupt void Excep_IRQ1(void) {    
    /* Disable switch 3 interrupts */
    IEN(ICU, IRQ1) = 0x0;
    /* Set standby ready flag as false */
    gSwitchStandbyReady = false;
            
    /* Check if interrupt was generated by falling edge */
    if(ICU.IRQCR[1].BIT.IRQMD == 0x1) {
        /* Start debounce timer */
        StartDebounceTimer(DEBOUNCE_SHORT);    
    
        /* Set detection direction as rising edge */
        ICU.IRQCR[1].BIT.IRQMD = 0x2;
        
        /* Set global switch flag to indicate SW3 is held down */
        gSwitchFlag |= SWITCHHOLD_3;
    } else {
        /* Start debounce timer */
        StartDebounceTimer(DEBOUNCE_LONG);    
      
        /* Set detection direction to falling edge */
        ICU.IRQCR[1].BIT.IRQMD = 0x1;
    
        /* Clear SW3 held-down flag bit in switch flag */
        gSwitchFlag &= (SWITCHPRESS_ALL | ~SWITCHHOLD_3);
    
        /* Set global switch flag to indicate SW3 press complete */
        gSwitchFlag |= SWITCHPRESS_3;
LED2=LED_OFF;
        /* Check if switch release callback function is not NULL */
        if(gSwitchReleaseCallbackFunc) {
            /* Execute user callback function */
            gSwitchReleaseCallbackFunc();
        }
    }
}

#pragma vector=VECT_ICU_IRQ2
__interrupt void Excep_IRQ2(void) {    
    /* Disable switch 2 interrupts */
    IEN(ICU, IRQ2) = 0x0;
    /* Set standby ready flag as false */
    gSwitchStandbyReady = false;
            
    /* Check if interrupt was generated by falling edge */
    if(ICU.IRQCR[2].BIT.IRQMD == 0x1) {
        /* Start debounce timer */
        StartDebounceTimer(DEBOUNCE_SHORT);    
    
        /* Set detection direction as rising edge */
        ICU.IRQCR[2].BIT.IRQMD = 0x2;
        
        /* Set global switch flag to indicate SW2 is held down */
        gSwitchFlag |= SWITCHHOLD_2;
    } else {  
        /* Start debounce timer */
        StartDebounceTimer(DEBOUNCE_LONG);    
      
        /* Set detection direction to falling edge */
        ICU.IRQCR[2].BIT.IRQMD = 0x1;
    
        /* Clear SW2 held-down flag bit in switch flag */
        gSwitchFlag &= (SWITCHPRESS_ALL | ~SWITCHHOLD_2);
    
        /* Set global switch flag to indicate SW2 press complete */
        gSwitchFlag |= SWITCHPRESS_2;
LED1=LED_OFF;  
        /* Check if switch release callback function is not NULL */
        if(gSwitchReleaseCallbackFunc) {
            /* Execute user callback function */
            gSwitchReleaseCallbackFunc();
        }
    }
}
  
#pragma vector=VECT_ICU_IRQ3
__interrupt void Excep_IRQ3(void) {    
    /* Disable switch 1 interrupts */
    IEN(ICU, IRQ3) = 0x0;
    /* Set standby ready flag as false */
    gSwitchStandbyReady = false;
            
    /* Check if interrupt was generated by falling edge */
    if(ICU.IRQCR[3].BIT.IRQMD == 0x1) {
        /* Start debounce timer */
        StartDebounceTimer(DEBOUNCE_SHORT);    
    
        /* Set detection direction as rising edge */
        ICU.IRQCR[3].BIT.IRQMD = 0x2;
        
        /* Set global switch flag to indicate SW1 is held down */
        gSwitchFlag |= SWITCHHOLD_1;
    } else {  
        /* Start debounce timer */
        StartDebounceTimer(DEBOUNCE_LONG);    
      
        /* Set detection direction to falling edge */
        ICU.IRQCR[3].BIT.IRQMD = 0x1;
    
        /* Clear SW1 held-down flag bit in switch flag */
        gSwitchFlag &= (SWITCHPRESS_ALL | ~SWITCHHOLD_1);
    
        /* Set global switch flag to indicate SW1 press complete */
        gSwitchFlag |= SWITCHPRESS_1;
LED0=LED_OFF;  
        /* Check if switch release callback function is not NULL */
        if(gSwitchReleaseCallbackFunc) {
            /* Execute user callback function */
            gSwitchReleaseCallbackFunc();
        }
    }
}

void StartDebounceTimer(uint16_t compare_match) {  
    static bool timer_initialised = false;
  
    /* Check if the CMT timer is not initialised (first time function has been
       called). */
    if(!timer_initialised) {  
        
        SYSTEM.PRCR.WORD = 0xA503; /* Disable register protection */
        MSTP_CMT0 = 0;             /* Enable the CMT0 module */
  
        /* Re-enable register protection */
        SYSTEM.PRCR.BIT.PRKEY = 0xA5u;
        SYSTEM.PRCR.WORD &= 0xFF00;  
  
        CMT0.CMCR.BIT.CKS = 0x2; /* Set CMT0 clock source as PLCK/512 */ 
        CMT0.CMCR.BIT.CMIE = 1;  /* Enable compare match interrupt */  
        IEN(CMT0, CMI0) = 1;     /* Enable CMT0 interrupt request */
        IPR(CMT0, CMI0) = 12u;   /* Set interrupt priority to 12 */

        timer_initialised = true;
    }
  
    /* Set compare match to to generate debounce period */
    CMT0.CMCOR = compare_match;
    CMT0.CMCNT = 0x0000;     /* Reset count to zero */
    CMT.CMSTR0.BIT.STR0 = 1; /* Start timer */
}

#pragma vector=VECT_CMT0_CMI0
__interrupt void Excep_CMTU0_CMT0(void) {
    /* Stop the CMT0 timer running */
    CMT.CMSTR0.BIT.STR0 = 0;
  
    IR(ICU, IRQ0) = 0;    /* Clear IRQ0 interrupt flag */
    IEN(ICU, IRQ0) = 0x1; /* Re-enable switch 1 interrupts */

    IR(ICU, IRQ1) = 0;    /* Clear IRQ1 interrupt flag */
    IEN(ICU, IRQ1) = 0x1; /* Re-enable switch 2 interrupts */

    IR(ICU, IRQ2) = 0;    /* Clear IRQ2 interrupt flag */
    IEN(ICU, IRQ2) = 0x1; /* Re-enable switch 3 interrupts */

    IR(ICU, IRQ3) = 0;    /* Clear IRQ3 interrupt flag */
    IEN(ICU, IRQ3) = 0x1; /* Re-enable switch 3 interrupts */
  
    /* Check if switch 4 hold flag is set */ 
    if((gSwitchFlag & SWITCHHOLD_ALL) & SWITCHHOLD_4) {
        /* Check if switch 4 pin level is high (switch press duration
           less than debounce, invalid switch press) */
        if(PORT3.PIDR.BIT.B0) {
            /* Reset detection direction to falling edge */
            ICU.IRQCR[0].BIT.IRQMD = 0x1;
      
            /* Clear switch press flag */
            gSwitchFlag &= (SWITCHPRESS_ALL | ~SWITCHHOLD_4);
      
            /* Increment detected switch faults counter */
            gSwitchFaultsDetected++;
        } else { /* Switch 4 pin level is low (valid switch press) */
LED3=LED_ON;
            /* Check if switch press callback function is not NULL */
            if(gSwitchPressCallbackFunc) {
                /* Execute user callback function */
                gSwitchPressCallbackFunc();
            }
        }
    }
  
    /* Check if switch 3 hold flag is set */   
    if((gSwitchFlag & SWITCHHOLD_ALL) & SWITCHHOLD_3) {
        /* Check if switch 3 pin level is high (switch press duration
           less than debounce, invalid switch press) */
        if(PORT3.PIDR.BIT.B1) {
            /* Reset detection direction to falling edge */
            ICU.IRQCR[1].BIT.IRQMD = 0x1;
      
            /* Clear switch press flag */
            gSwitchFlag &= (SWITCHPRESS_ALL | ~SWITCHHOLD_3);
      
            /* Increment detected switch faults counter */
            gSwitchFaultsDetected++;
        } else { /* Switch 3 pin level is low (valid switch press) */
LED2=LED_ON;
            /* Check if switch press callback function is not NULL */
            if(gSwitchPressCallbackFunc) {
                /* Execute user callback function */
                gSwitchPressCallbackFunc();
            }
        }
    }
  
    /* Check if switch 2 hold flag is set */ 
    if((gSwitchFlag & SWITCHHOLD_ALL) & SWITCHHOLD_2) {
        /* Check if switch 2 pin level is high (switch press duration
           less than debounce, invalid switch press) */
        if(PORT3.PIDR.BIT.B2) {
            /* Reset detection direction to falling edge */
            ICU.IRQCR[2].BIT.IRQMD = 0x1;
      
            /* Clear switch press flag */
            gSwitchFlag &= (SWITCHPRESS_ALL | ~SWITCHHOLD_2);
      
            /* Increment detected switch faults counter */
            gSwitchFaultsDetected++;
        } else { /* Switch 2 pin level is low (valid switch press) */
LED1=LED_ON;
            /* Check if switch press callback function is not NULL */
            if(gSwitchPressCallbackFunc) {
                /* Execute user callback function */
                gSwitchPressCallbackFunc();
            }
        }
    }

    /* Check if switch 1 hold flag is set */ 
    if((gSwitchFlag & SWITCHHOLD_ALL) & SWITCHHOLD_1) {
        /* Check if switch 1 pin level is high (switch press duration
           less than debounce, invalid switch press) */
        if(PORT3.PIDR.BIT.B3) {
            /* Reset detection direction to falling edge */
            ICU.IRQCR[3].BIT.IRQMD = 0x1;
      
            /* Clear switch press flag */
            gSwitchFlag &= (SWITCHPRESS_ALL | ~SWITCHHOLD_1);
      
            /* Increment detected switch faults counter */
            gSwitchFaultsDetected++;
        } else { /* Switch 1 pin level is low (valid switch press) */
LED0=LED_ON;
            /* Check if switch press callback function is not NULL */
            if(gSwitchPressCallbackFunc) {
                /* Execute user callback function */
                gSwitchPressCallbackFunc();
            }
        }
    }
  
    /* Check if any switches are held down */
    if(0x00 == (gSwitchFlag & SWITCHHOLD_ALL)) {    
        gSwitchStandbyReady = true;
    }

    /* Clear the interrupt flag */
    ICU.IR[IR_CMT0_CMI0].BIT.IR = 0;
}
